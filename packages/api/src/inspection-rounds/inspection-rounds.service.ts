import {
  BadRequestException,
  ConflictException,
  Injectable,
} from '@nestjs/common'
import { CreateInspectionRoundInput } from './dto/create-inspection-round.input'
import { UpdateInspectionRoundInput } from './dto/update-inspection-round.input'
import {
  InspectionRound,
  RoundStatus,
} from './entities/inspection-round.entity'
import { MongoRepository, ObjectId } from 'typeorm'
import { RoomsService } from 'src/rooms/rooms.service'
import { InjectRepository } from '@nestjs/typeorm'

@Injectable()
export class InspectionRoundsService {
  constructor(
    @InjectRepository(InspectionRound)
    private readonly inspectionRoundRepository: MongoRepository<InspectionRound>,
    private readonly roomsService: RoomsService,
  ) {}

  async create(input: CreateInspectionRoundInput): Promise<InspectionRound> {
    try {
      // Validate that all rooms belong to the same building
      await this.validateRoomsFromSameBuilding(
        input.roomOrder,
        input.buildingId,
      )

      // const inspectionRound = this.inspectionRoundRepository.create({
      //   buildingId: input.buildingId,
      //   assignedToUserId: input.assignedToUserId,
      //   plannedAt: input.plannedAt,
      //   roomOrder: input.roomOrder,
      //   status: input.status || RoundStatus.PLANNED,
      // })
      const inspectionRound = this.inspectionRoundRepository.create(input)

      // Name will be auto-generated by the @BeforeInsert hook
      return await this.inspectionRoundRepository.save(inspectionRound)
    } catch (error) {
      // Handle unique constraint violation
      if (error?.code === 11000) {
        // Extract date for user-friendly error message
        const dateStr = input.plannedAt.toISOString().split('T')[0]
        throw new ConflictException(
          `An inspection round for building "${input.buildingId}" on "${dateStr}" is already assigned to this user.`,
        )
      }
      throw error // Re-throw other errors
    }
  }

  private async validateRoomsFromSameBuilding(
    roomCodes: string[],
    buildingId: string,
  ): Promise<void> {
    // Get all rooms by their codes
    const rooms = await this.roomsService.findByCodesAndBuilding(
      roomCodes,
      buildingId,
    )

    // Check if all requested rooms were found
    if (rooms.length !== roomCodes.length) {
      const foundCodes = rooms.map(room => room.code)
      const missingCodes = roomCodes.filter(code => !foundCodes.includes(code))
      throw new BadRequestException(
        `Some rooms not found in building ${buildingId}: ${missingCodes.join(', ')}`,
      )
    }

    // Check if all rooms belong to the specified building
    const invalidRooms = rooms.filter(room => room.buildingId !== buildingId)
    if (invalidRooms.length > 0) {
      const invalidCodes = invalidRooms.map(room => room.code)
      throw new BadRequestException(
        `These rooms don't belong to building ${buildingId}: ${invalidCodes.join(', ')}`,
      )
    }
  }
  // create(createInspectionRoundInput: CreateInspectionRoundInput) {
  //   return 'This action adds a new inspectionRound'
  // }

  findAll() {
    return `This action returns all inspectionRounds`
  }

  // findOne(id: number) {
  //   return `This action returns a #${id} inspectionRound`
  // }
  findOne(id: string) {
    // EXTRA STEP check if id is a valid ObjectId
    if (!ObjectId.isValid(id)) throw new Error('Invalid ObjectId')

    const objID = new ObjectId(id)
    return this.inspectionRoundRepository.findOneByOrFail({ id: objID })
  }

  update(id: number, updateInspectionRoundInput: UpdateInspectionRoundInput) {
    return `This action updates a #${id} inspectionRound`
  }

  remove(id: number) {
    return `This action removes a #${id} inspectionRound`
  }
}
